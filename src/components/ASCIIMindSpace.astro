---
// Tumbolia - Where dormant thoughts wait in cellular suspension
// Inspired by GEB: "the land of dead hiccups and extinguished light bulbs"
---

<div class="tumbolia-space">
  <canvas id="tumbolia-canvas"></canvas>
  <div class="tumbolia-overlay">
    <div class="terminal-header">
      <span class="terminal-prompt">tumbolia@void:~$</span>
      <span class="cursor-blink">_</span>
    </div>
    <div class="depth-indicator">
      <span class="depth-label">depth:</span>
      <span class="depth-value" id="depth-value">∞</span>
    </div>
  </div>
</div>

<script>
  const canvas = document.getElementById('tumbolia-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;
  const depthValue = document.getElementById('depth-value') as HTMLElement;

  let width = window.innerWidth;
  let height = Math.min(700, window.innerHeight * 0.85);

  canvas.width = width;
  canvas.height = height;

  // Dormant thoughts that occasionally flicker to life
  const dormantThoughts = [
    'waiting',
    'suspended',
    'hiccup',
    'echo',
    'loop',
    'forgotten',
    'returning',
    'between',
    'dormant',
    'liminal',
  ];

  // Cellular grid (larger, more visible)
  const cellSize = 60;
  const cols = Math.ceil(width / cellSize);
  const rows = Math.ceil(height / cellSize);

  // Mouse interaction
  let mouseX = width / 2;
  let mouseY = height / 2;
  let isMouseActive = false;

  interface Cell {
    x: number;
    y: number;
    state: 'dormant' | 'awakening' | 'alive' | 'fading';
    energy: number;
    thought: string | null;
    depth: number;
    pulsePhase: number;
    connections: Array<{x: number, y: number}>;
    shape: 'hexagon' | 'circle' | 'square' | 'triangle';
    mouseInfluence: number;
  }

  let cells: Cell[][] = [];
  let time = 0;
  let zoomPhase = 0;
  let recursionDepth = 0;

  // Initialize cellular grid
  function initCells() {
    cells = [];
    const shapes: Array<'hexagon' | 'circle' | 'square' | 'triangle'> = ['hexagon', 'circle', 'square', 'triangle'];
    for (let y = 0; y < rows; y++) {
      cells[y] = [];
      for (let x = 0; x < cols; x++) {
        cells[y][x] = {
          x,
          y,
          state: 'dormant',
          energy: Math.random() * 0.5,
          thought: Math.random() < 0.08 ? dormantThoughts[Math.floor(Math.random() * dormantThoughts.length)] : null,
          depth: 0,
          pulsePhase: Math.random() * Math.PI * 2,
          connections: [],
          shape: shapes[Math.floor(Math.random() * shapes.length)],
          mouseInfluence: 0
        };
      }
    }
  }

  initCells();

  // Occasionally awaken a cell (more frequently)
  function awakenRandomCell() {
    if (Math.random() < 0.015) {
      const x = Math.floor(Math.random() * cols);
      const y = Math.floor(Math.random() * rows);
      if (cells[y] && cells[y][x] && cells[y][x].state === 'dormant') {
        cells[y][x].state = 'awakening';
        cells[y][x].energy = 0;
      }
    }
  }

  // Update mouse influence on cells
  function updateMouseInfluence() {
    if (!isMouseActive) return;

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = cells[y][x];
        const cellX = cell.x * cellSize + cellSize / 2;
        const cellY = cell.y * cellSize + cellSize / 2;

        const dist = Math.sqrt((mouseX - cellX) ** 2 + (mouseY - cellY) ** 2);
        const maxDist = 150;

        if (dist < maxDist) {
          const influence = 1 - (dist / maxDist);
          cell.mouseInfluence = Math.max(cell.mouseInfluence, influence);

          // Awaken cells near cursor
          if (influence > 0.7 && cell.state === 'dormant' && Math.random() < 0.1) {
            cell.state = 'awakening';
            cell.energy = 0;
          }
        } else {
          cell.mouseInfluence *= 0.95;
        }
      }
    }
  }

  // Update cell states (like Conway's Game of Life, but slower, more organic)
  function updateCells() {
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = cells[y][x];

        // Update based on state
        if (cell.state === 'awakening') {
          cell.energy += 0.02;
          if (cell.energy >= 1) {
            cell.state = 'alive';
            // Create connections to nearby cells
            const neighbors = getNeighbors(x, y);
            cell.connections = neighbors.slice(0, 2).map(n => ({x: n.x, y: n.y}));
          }
        } else if (cell.state === 'alive') {
          cell.energy = Math.min(1, cell.energy + 0.005);
          cell.pulsePhase += 0.02;

          // Occasionally fade
          if (Math.random() < 0.001) {
            cell.state = 'fading';
          }
        } else if (cell.state === 'fading') {
          cell.energy -= 0.015;
          if (cell.energy <= 0) {
            cell.state = 'dormant';
            cell.energy = Math.random() * 0.3;
            cell.connections = [];
          }
        } else if (cell.state === 'dormant') {
          // Dormant cells slowly pulse
          cell.pulsePhase += 0.005;
          cell.energy = 0.1 + Math.sin(cell.pulsePhase) * 0.05;
        }
      }
    }
  }

  function getNeighbors(x: number, y: number) {
    const neighbors = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
          neighbors.push({x: nx, y: ny});
        }
      }
    }
    return neighbors;
  }

  // Draw cell as a universe or as a cell (recursive visualization)
  function drawCell(cell: Cell, scale: number = 1) {
    const centerX = cell.x * cellSize + cellSize / 2;
    const centerY = cell.y * cellSize + cellSize / 2;

    ctx.save();
    ctx.translate(centerX, centerY);

    // Apply zoom/recursion effect
    const zoomScale = 1 + Math.sin(zoomPhase + cell.x * 0.1 + cell.y * 0.1) * 0.05;
    ctx.scale(zoomScale, zoomScale);

    // Color based on state (much more visible)
    let color, alpha;
    const mouseBoost = cell.mouseInfluence * 0.4;

    if (cell.state === 'dormant') {
      color = '#4CD7D0';
      alpha = (cell.energy * 0.4) + mouseBoost;
    } else if (cell.state === 'awakening') {
      color = '#B565D8';
      alpha = (cell.energy * 0.7) + mouseBoost;
    } else if (cell.state === 'alive') {
      const pulse = Math.sin(cell.pulsePhase) * 0.3 + 0.7;
      color = '#FF3E8E';
      alpha = (cell.energy * pulse * 0.9) + mouseBoost;
    } else {
      color = '#F28AAE';
      alpha = (cell.energy * 0.5) + mouseBoost;
    }

    // Draw cell membrane (varied shapes)
    const radius = cellSize * 0.4;
    ctx.beginPath();

    if (cell.shape === 'hexagon') {
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
    } else if (cell.shape === 'circle') {
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
    } else if (cell.shape === 'square') {
      ctx.rect(-radius, -radius, radius * 2, radius * 2);
    } else if (cell.shape === 'triangle') {
      for (let i = 0; i < 3; i++) {
        const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
    }

    ctx.strokeStyle = color;
    ctx.lineWidth = 2 + cell.mouseInfluence * 2;
    ctx.globalAlpha = alpha;
    ctx.stroke();

    // Add glow
    ctx.shadowColor = color;
    ctx.shadowBlur = 10 + cell.mouseInfluence * 15;

    // Draw inner glow for alive cells
    if (cell.state === 'alive' || cell.state === 'awakening') {
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.globalAlpha = alpha * 0.3;
      ctx.fill();
    }

    // Draw thought if present
    if (cell.thought && (cell.state === 'alive' || cell.state === 'awakening')) {
      ctx.font = `${cellSize * 0.2}px "IBM Plex Mono", monospace`;
      ctx.fillStyle = color;
      ctx.globalAlpha = alpha * 0.8;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(cell.thought, 0, 0);
    }

    // Draw nucleus (smaller circle suggesting recursion)
    if (cell.state !== 'dormant') {
      ctx.beginPath();
      ctx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.globalAlpha = alpha * 0.5;
      ctx.stroke();
    }

    ctx.restore();
  }

  // Draw connections between cells
  function drawConnections() {
    ctx.globalAlpha = 0.15;
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = cells[y][x];
        if (cell.state === 'alive' && cell.connections.length > 0) {
          const fromX = cell.x * cellSize + cellSize / 2;
          const fromY = cell.y * cellSize + cellSize / 2;

          cell.connections.forEach(conn => {
            const toX = conn.x * cellSize + cellSize / 2;
            const toY = conn.y * cellSize + cellSize / 2;

            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.strokeStyle = '#FF3E8E';
            ctx.lineWidth = 0.5;
            ctx.stroke();
          });
        }
      }
    }
    ctx.globalAlpha = 1;
  }

  // Recursive zoom effect - suggesting infinite depth
  function drawRecursiveHint() {
    const centerX = width / 2;
    const centerY = height / 2;

    // Draw expanding/contracting circles suggesting recursion
    for (let i = 0; i < 3; i++) {
      const phase = zoomPhase + i * (Math.PI * 2 / 3);
      const radius = 80 + Math.sin(phase) * 30 + i * 40;
      const alpha = (Math.sin(phase) * 0.5 + 0.5) * 0.1;

      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = i % 2 === 0 ? '#4CD7D0' : '#FF3E8E';
      ctx.lineWidth = 1;
      ctx.globalAlpha = alpha;
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Update depth display
  function updateDepth() {
    const depths = ['∞', '⊕', '⊗', '⊙', '◉', '○'];
    const index = Math.floor((time / 200) % depths.length);
    depthValue.textContent = depths[index];
  }

  function draw() {
    time++;
    zoomPhase += 0.003;

    // Subtle gradient background
    const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, height/2);
    gradient.addColorStop(0, '#0A0608');
    gradient.addColorStop(0.5, '#110A0D');
    gradient.addColorStop(1, '#0A0608');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // Update mouse influence and cells
    updateMouseInfluence();

    if (time % 2 === 0) {
      updateCells();
      awakenRandomCell();
    }

    // Draw recursive hint circles
    drawRecursiveHint();

    // Draw connections first (background layer)
    drawConnections();

    // Draw all cells
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        drawCell(cells[y][x]);
      }
    }

    // Update depth indicator
    if (time % 20 === 0) {
      updateDepth();
    }

    requestAnimationFrame(draw);
  }

  draw();

  // Mouse tracking
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
    isMouseActive = true;
  });

  canvas.addEventListener('mouseleave', () => {
    isMouseActive = false;
  });

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // Awaken cells near click
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = cells[y][x];
        const cellX = cell.x * cellSize + cellSize / 2;
        const cellY = cell.y * cellSize + cellSize / 2;
        const dist = Math.sqrt((clickX - cellX) ** 2 + (clickY - cellY) ** 2);

        if (dist < 100 && cell.state === 'dormant') {
          cell.state = 'awakening';
          cell.energy = 0;
        }
      }
    }
  });

  // Handle resize
  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = Math.min(700, window.innerHeight * 0.85);
    canvas.width = width;
    canvas.height = height;
    initCells();
  });
</script>

<style>
  .tumbolia-space {
    position: relative;
    width: 100%;
    height: 700px;
    max-height: 85vh;
    background: #0A0608;
    overflow: hidden;
    margin-bottom: 3rem;
  }

  #tumbolia-canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: crosshair;
  }

  .tumbolia-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 10;
  }

  .terminal-header {
    position: absolute;
    top: 2rem;
    left: 2rem;
    font-family: var(--font-mono);
    font-size: 0.875rem;
    color: #4CD7D0;
    text-shadow: 0 0 10px rgba(76, 215, 208, 0.4);
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .terminal-prompt {
    opacity: 0.7;
  }

  .cursor-blink {
    animation: blink 1.5s steps(2, start) infinite;
    color: #B565D8;
  }

  .depth-indicator {
    position: absolute;
    bottom: 2rem;
    right: 2rem;
    font-family: var(--font-mono);
    font-size: 0.875rem;
    color: #FF3E8E;
    text-shadow: 0 0 10px rgba(255, 62, 142, 0.4);
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .depth-label {
    opacity: 0.6;
    font-size: 0.75rem;
  }

  .depth-value {
    font-size: 1.25rem;
    opacity: 0.9;
  }

  @keyframes blink {
    to {
      opacity: 0;
    }
  }

  /* Subtle vignette */
  .tumbolia-space::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(
      ellipse at center,
      transparent 0%,
      rgba(10, 6, 8, 0.3) 70%,
      rgba(10, 6, 8, 0.6) 100%
    );
    pointer-events: none;
    z-index: 5;
  }

  /* Very subtle scanlines */
  .tumbolia-space::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.03) 2px,
      rgba(0, 0, 0, 0.03) 4px
    );
    pointer-events: none;
    z-index: 5;
    opacity: 0.5;
  }

  @media (max-width: 768px) {
    .tumbolia-space {
      height: 500px;
    }

    .terminal-header {
      font-size: 0.75rem;
      top: 1rem;
      left: 1rem;
    }

    .depth-indicator {
      font-size: 0.75rem;
      bottom: 1rem;
      right: 1rem;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .cursor-blink {
      animation: none;
      opacity: 1;
    }
  }
</style>
